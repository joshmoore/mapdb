package org.mapdb

import java.io.File
import java.io.IOException

import org.junit.Assert.assertTrue
import org.junit.Test
import java.io.ByteArrayOutputStream
import java.io.InputStream
import org.junit.Assert.*
import kotlin.test.assertFailsWith

/**
 * Runs custom code in forked JVM, and verify if data survive JVM crash.
 * JVM crash is generated by `kill PID -9` or using Unsafe set invalid memory
 */
abstract class CrashJVM {

    private var testDir: File? = null
    private var seedEndDir: File? = null
    private var seedStartDir: File? = null

    fun setTestDir(tempDir: File) {
        this.testDir = tempDir
        this.seedEndDir = File(tempDir, "seedEndDir")
        this.seedStartDir = File(tempDir, "seedStartDir")
        assertTrue(seedEndDir!!.isDirectory)
        assertTrue(seedStartDir!!.isDirectory)

    }
    fun getTestDir():File = testDir!!;



    abstract fun doInJVM(startSeed: Long, params:String)


    abstract fun verifySeed(startSeed:Long, endSeed: Long, params:String):Long

    abstract fun createParams():String;



    fun startSeed(seed: Long) {
        File(seedStartDir, "" + seed).createNewFile()
    }


    fun commitSeed(seed: Long) {
        File(seedEndDir, "" + seed).createNewFile()
    }



    companion object {

        internal fun findHighestSeed(seedDir: File): Long {
            var ret: Long = -1
            for (child in seedDir.listFiles()!!) {
                val num = java.lang.Long.parseLong(child.name)
                ret = Math.max(ret, num)
                child.delete()
            }
            return ret
        }

        @JvmStatic fun main(args: Array<String>) {
            print("started_")
            try {
                assertTrue("need args", args.size == 5)
                val testClass = args[0]
                val test = Class.forName(testClass).newInstance() as CrashJVM

                val tempDir = File(args[1])
                assertTrue(tempDir.isDirectory)
                test.setTestDir(tempDir)

                val killDelay = args[2].toLong()
                val t = Thread({
                    Thread.sleep(killDelay)
                    killThisJVM()
                })
                t.isDaemon = true
                t.start();

                val startSeed = args[3].toLong()
                val params = args[4]
                test.doInJVM(startSeed, params)
                System.err.println("Failure, method quitNatural exit")
                System.exit(182)

            } catch (e: Throwable) {
                e.printStackTrace()
                System.exit(188)
            }
        }

        internal fun killThisJVM() {
            val pid = File("/proc/self").canonicalFile.name

            java.lang.Long.valueOf(pid)
            print("killed")
            val b = ProcessBuilder("kill", "-9", pid)
            b.start()
            Thread.sleep(10000)
            println("KILL - Still alive")
            System.exit(-11123121);
            //TODO Unsafe kill if not on linux
        }


        internal fun jvmExecutable(): String {
            val exec = if (System.getProperty("os.name").startsWith("Win"))
                    "java.exe"
                else
                    "java"
            val javaHome = System.getProperty("java.home")
            if (javaHome == null || "" == javaHome)
                return exec
            return javaHome + File.separator + "bin" + File.separator + exec
        }

        internal fun outStreamToString(`in`: InputStream): String {
            val out = ByteArrayOutputStream()
            var b = `in`.read()
            while (b != -1) {
                out.write(b)
                b = `in`.read()
            }
            return String(out.toByteArray())
        }


        fun run(test: CrashJVM, killDelay: Long=500, time: Long=60*1000) {
            val testDir = File.createTempFile("mapdb", "jvmCrashTest")
            try {
                testDir.delete()
                testDir.mkdirs()
                val seedEndDir = File(testDir, "seedEndDir")
                seedEndDir.mkdirs()
                val seedStartDir = File(testDir, "seedStartDir")
                seedStartDir.mkdirs()
                test.setTestDir(testDir);

                val endTimestamp = System.currentTimeMillis() + time

                val params = test.createParams()

                var seed = 0L;
                while (System.currentTimeMillis() < endTimestamp) {
                    val b = ProcessBuilder(
                            jvmExecutable(),
                            "-classpath",
                            System.getProperty("java.class.path"),
                            CrashJVM::class.java.name,
                            test.javaClass.name,
                            testDir.getAbsolutePath(),
                            "" + killDelay,
                            "" + seed,
                            params)
                    val pr = b.start()
                    pr.waitFor() //it should kill itself after some time

                    Thread.sleep(100)// just in case

                    //handle output streams
                    val out = outStreamToString(pr.inputStream)

                    val err = outStreamToString(pr.errorStream);
                    if(err.length>0) {
                        System.err.print("\n=====FORKED JVM START=====\n" +
                                err +
                                "\n======FORKED JVM END======\n")
                    }
                    assertTrue(out, out.startsWith("started_"))
                    assertTrue(out, out.endsWith("_killed"))
                    assertEquals(137, pr.exitValue().toLong())

                    // handle seeds
                    val startSeed = findHighestSeed(seedStartDir)
                    val endSeed = findHighestSeed(seedEndDir)

                    if(endSeed!=-1L)
                        seed = test.verifySeed(startSeed, endSeed, params);

                }
            }finally{
                TT.tempDelete(testDir);
            }
        }
    }

}


class CrashJVMTestFail:CrashJVM(){

    override fun createParams() = ""


    override fun verifySeed(startSeed: Long, endSeed: Long, params:String): Long {
        val f = File(getTestDir(), "aaa")
        val seed = f.inputStream().use {
            DBUtil.unpackLong(it)
        }
        assertTrue(seed>=startSeed)
        assertTrue(endSeed==-1L && seed<=endSeed)
        return seed+1
    }

    override fun doInJVM(startSeed: Long, params:String) {
        val f = File(getTestDir(), "aaa")
        var seed = startSeed;

        while(true){
            seed++
            startSeed(seed)
            f.outputStream().use {
                DBUtil.packLong(it, seed)
            }
            commitSeed(seed)
        }
    }


    @Test fun test(){
        assertFailsWith(Throwable::class, {
            CrashJVM.run(this,time=2000, killDelay = 200)
        })
    }

}


class CrashJVMTest:CrashJVM(){

    override fun createParams() = ""

    override fun verifySeed(startSeed: Long, endSeed: Long, params:String): Long {
        for(seed in startSeed .. endSeed){
            assertTrue(File(getTestDir(),""+seed).exists())
        }

        return Math.max(startSeed,endSeed)+1;
    }

    override fun doInJVM(startSeed: Long, params:String) {
        var seed = startSeed;

        while(true){
            seed++
            startSeed(seed)
            val f = File(getTestDir(), ""+seed)
            f.createNewFile()
            commitSeed(seed)
        }
    }

    @Test fun test(){
        val runtime = 4000L + TT.testScale()*60*1000;
        val start = System.currentTimeMillis()
        CrashJVM.run(this, time=runtime, killDelay = 200)
        assertTrue(System.currentTimeMillis()-start >= runtime)
    }
}
